// Package objectstore provides simple ObjectStore wrapper for immutable message storage.
// It uses NATS ObjectStore (NOT KeyValue) to store parsed messages as JSON blobs
// with time-bucketed slash-based keys for efficient organization and retrieval.
package objectstore

import (
	"context"
	"encoding/json"
	"fmt"
	"strings"
	"time"

	"github.com/c360/semstreams/message"
	"github.com/c360/semstreams/metric"
	"github.com/c360/semstreams/natsclient"
	"github.com/c360/semstreams/pkg/cache"
	"github.com/c360/semstreams/storage"
	"github.com/nats-io/nats.go/jetstream"
)

// Verify Store implements storage.Store interface
var _ storage.Store = (*Store)(nil)

// Store provides simple ObjectStore wrapper for message storage.
// Messages are stored as immutable JSON blobs with time-bucketed slash-based keys.
//
// Composition-Friendly Design:
//   - Pluggable KeyGenerator (inject custom key generation)
//   - Pluggable MetadataExtractor (inject custom metadata extraction)
//   - No hardcoded semantic requirements
type Store struct {
	client            *natsclient.Client
	bucketName        string
	store             jetstream.ObjectStore
	dataCache         cache.Cache[[]byte]
	keyGenerator      storage.KeyGenerator
	metadataExtractor storage.MetadataExtractor
	metrics           *storeMetrics
}

// NewStoreWithConfig creates a new ObjectStore with cache configuration.
// Uses NATS ObjectStore (NOT KeyValue) for immutable message storage.
func NewStoreWithConfig(ctx context.Context, client *natsclient.Client, cfg Config) (*Store, error) {
	return NewStoreWithConfigAndMetrics(ctx, client, cfg, nil)
}

// NewStoreWithConfigAndMetrics creates a new ObjectStore with cache configuration and optional metrics.
// Uses NATS ObjectStore (NOT KeyValue) for immutable message storage.
func NewStoreWithConfigAndMetrics(
	ctx context.Context,
	client *natsclient.Client,
	cfg Config,
	metricsRegistry *metric.MetricsRegistry,
) (*Store, error) {
	bucketName := cfg.BucketName
	if bucketName == "" {
		bucketName = "MESSAGES"
	}

	js, err := client.JetStream()
	if err != nil {
		return nil, fmt.Errorf("failed to get JetStream context: %w", err)
	}

	storeConfig := jetstream.ObjectStoreConfig{
		Bucket:      bucketName,
		Description: "Immutable message storage",
		TTL:         24 * time.Hour, // Optional retention
	}

	// Use caller's context for ObjectStore operations
	store, err := js.CreateObjectStore(ctx, storeConfig)
	if err != nil {
		// Try to get existing store
		store, err = js.ObjectStore(ctx, bucketName)
		if err != nil {
			return nil, fmt.Errorf("failed to create/get object store: %w", err)
		}
	}

	// Create cache based on configuration with metrics
	dataCache, err := cache.NewFromConfig[[]byte](ctx, cfg.DataCache,
		cache.WithMetrics[[]byte](metricsRegistry, "objectstore"),
	)
	if err != nil {
		return nil, fmt.Errorf("failed to create data cache: %w", err)
	}

	// Use provided generators or defaults
	keyGen := cfg.KeyGenerator
	if keyGen == nil {
		keyGen = &DefaultKeyGenerator{}
	}

	metaExtractor := cfg.MetadataExtractor
	// metaExtractor can be nil - that's fine, we'll check before using

	// Initialize metrics if registry provided
	metrics, err := newStoreMetrics(metricsRegistry, bucketName)
	if err != nil {
		return nil, fmt.Errorf("failed to initialize metrics: %w", err)
	}

	return &Store{
		client:            client,
		bucketName:        bucketName,
		store:             store,
		dataCache:         dataCache,
		keyGenerator:      keyGen,
		metadataExtractor: metaExtractor,
		metrics:           metrics,
	}, nil
}

// Put stores raw binary data at the specified key (implements storage.Store interface).
// This is the low-level storage operation - callers provide the key and raw bytes.
// For message-specific storage with automatic key generation, use Store() instead.
func (s *Store) Put(ctx context.Context, key string, data []byte) error {
	start := time.Now()
	s.metrics.recordWriteOp("put")

	// Store bytes in NATS ObjectStore
	_, err := s.store.PutBytes(ctx, key, data)
	if err != nil {
		s.metrics.recordError("put")
		return fmt.Errorf("failed to put data: %w", err)
	}

	s.metrics.recordWriteLatency("put", time.Since(start).Seconds())

	// Add to cache after successful storage
	if s.dataCache != nil {
		s.dataCache.Set(key, data)
	}

	return nil
}

// Store saves a message and returns the generated key.
// Messages are stored as JSON bytes with keys generated by the configured KeyGenerator.
// If a MetadataExtractor is configured, metadata is extracted and stored with the object.
func (s *Store) Store(ctx context.Context, msg any) (string, error) {
	start := time.Now()
	s.metrics.recordWriteOp("store")

	// Generate key using pluggable generator
	key := s.keyGenerator.GenerateKey(msg)

	// Marshal to JSON bytes
	data, err := json.Marshal(msg)
	if err != nil {
		s.metrics.recordError("store")
		return "", fmt.Errorf("failed to marshal message: %w", err)
	}

	// Extract metadata if extractor is configured
	var meta map[string][]string
	if s.metadataExtractor != nil {
		meta = s.metadataExtractor.ExtractMetadata(msg)
	}

	// Store JSON bytes in ObjectStore with metadata
	if meta != nil {
		_, err = s.store.Put(ctx, jetstream.ObjectMeta{
			Name:    key,
			Headers: meta,
		}, strings.NewReader(string(data)))
	} else {
		// No metadata - simple storage
		_, err = s.store.PutBytes(ctx, key, data)
	}

	if err != nil {
		s.metrics.recordError("store")
		return "", fmt.Errorf("failed to store message: %w", err)
	}

	s.metrics.recordWriteLatency("store", time.Since(start).Seconds())

	// Add to cache after successful storage
	if s.dataCache != nil {
		s.dataCache.Set(key, data)
	}

	return key, nil
}

// Get retrieves a message by key.
// Checks cache first, then NATS ObjectStore if cache miss.
func (s *Store) Get(ctx context.Context, key string) ([]byte, error) {
	start := time.Now()
	s.metrics.recordReadOp("get")

	// Check cache first
	if s.dataCache != nil {
		if data, found := s.dataCache.Get(key); found {
			s.metrics.recordCacheHit()
			s.metrics.recordReadLatency("get", time.Since(start).Seconds())
			return data, nil
		}
		s.metrics.recordCacheMiss()
	}

	// Cache miss - get from NATS ObjectStore
	data, err := s.store.GetBytes(ctx, key)
	if err != nil {
		s.metrics.recordError("get")
		return nil, fmt.Errorf("failed to get message: %w", err)
	}

	s.metrics.recordReadLatency("get", time.Since(start).Seconds())

	// Add to cache for future requests
	if s.dataCache != nil {
		s.dataCache.Set(key, data)
	}

	return data, nil
}

// Delete removes a message (optional, messages are typically immutable).
// Also removes the message from cache if cached.
func (s *Store) Delete(ctx context.Context, key string) error {
	start := time.Now()
	s.metrics.recordDeleteOp()

	// Remove from cache first
	if s.dataCache != nil {
		s.dataCache.Delete(key)
	}

	// Remove from NATS ObjectStore
	err := s.store.Delete(ctx, key)
	if err != nil {
		s.metrics.recordError("delete")
		return err
	}

	s.metrics.recordDeleteLatency(time.Since(start).Seconds())
	return nil
}

// List returns keys matching a prefix (for debugging/inspection).
func (s *Store) List(ctx context.Context, prefix string) ([]string, error) {
	start := time.Now()
	s.metrics.recordListOp()

	var keys []string

	// Use List method which returns slice of ObjectInfo directly
	entries, err := s.store.List(ctx)
	if err != nil {
		s.metrics.recordError("list")
		return nil, fmt.Errorf("failed to list objects: %w", err)
	}

	for _, entry := range entries {
		if strings.HasPrefix(entry.Name, prefix) {
			keys = append(keys, entry.Name)
		}
	}

	s.metrics.recordListLatency(time.Since(start).Seconds())
	return keys, nil
}

// GetMetadata returns the metadata associated with a stored object.
// Returns empty map if the object has no metadata.
func (s *Store) GetMetadata(ctx context.Context, key string) (map[string][]string, error) {
	start := time.Now()
	s.metrics.recordReadOp("get_metadata")

	// Get object info which includes headers
	info, err := s.store.GetInfo(ctx, key)
	if err != nil {
		s.metrics.recordError("get_metadata")
		return nil, fmt.Errorf("failed to get object info: %w", err)
	}

	s.metrics.recordReadLatency("get_metadata", time.Since(start).Seconds())

	if info.Headers == nil {
		return make(map[string][]string), nil
	}

	return info.Headers, nil
}

// Close properly shuts down the ObjectStore and releases resources.
// This includes closing the cache if it's enabled.
func (s *Store) Close() error {
	if s.dataCache != nil {
		return s.dataCache.Close()
	}
	return nil
}

// DefaultKeyGenerator provides time-based key generation.
// Keys are formatted as: type/year/month/day/hour/identifier_timestamp
//
// The generator uses behavioral interfaces for optional enhancement:
//   - message.Typeable: Provides type information for key prefix
//   - message.Identifiable: Provides identifier for key uniqueness
//
// If interfaces aren't implemented, sensible defaults are used.
type DefaultKeyGenerator struct{}

// GenerateKey creates a time-bucketed slash-based key.
// Format: type/year/month/day/hour/identifier_timestamp
// Example: sensor.temperature.v1/2024/01/19/14/device-123_1705677443
func (g *DefaultKeyGenerator) GenerateKey(msg any) string {
	now := time.Now()

	// Extract type if message implements Message interface
	msgType := "message"
	if m, ok := msg.(message.Message); ok {
		msgType = m.Type().String()
	}

	// Extract identifier from message ID
	identifier := "unknown"
	if m, ok := msg.(message.Message); ok {
		identifier = m.ID()
	}

	// Format: type/year/month/day/hour/identifier_timestamp
	// Example: sensor.temperature.v1/2024/01/19/14/msg-uuid_1705677443
	key := fmt.Sprintf("%s/%04d/%02d/%02d/%02d/%s_%d",
		msgType,
		now.Year(),
		now.Month(),
		now.Day(),
		now.Hour(),
		identifier,
		now.Unix(),
	)

	return key
}
