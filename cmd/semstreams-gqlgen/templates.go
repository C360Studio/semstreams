package main

import (
	"bytes"
	"fmt"
	"strings"
	"text/template"
	"unicode"

	"github.com/c360/semstreams/errors"
	"github.com/vektah/gqlparser/v2/ast"
)

// Go reserved words that cannot be used as identifiers
var goReservedWords = map[string]bool{
	"break":       true,
	"case":        true,
	"chan":        true,
	"const":       true,
	"continue":    true,
	"default":     true,
	"defer":       true,
	"else":        true,
	"fallthrough": true,
	"for":         true,
	"func":        true,
	"go":          true,
	"goto":        true,
	"if":          true,
	"import":      true,
	"interface":   true,
	"map":         true,
	"package":     true,
	"range":       true,
	"return":      true,
	"select":      true,
	"struct":      true,
	"switch":      true,
	"type":        true,
	"var":         true,
}

// Maximum length for generated Go identifiers
const maxIdentifierLength = 120

// sanitizeIdentifier converts a string to a valid Go identifier
// Replaces invalid characters with underscores and handles reserved words
func sanitizeIdentifier(name string) string {
	if name == "" {
		return name
	}

	// Replace invalid characters with underscores
	sanitized := strings.Map(func(r rune) rune {
		if unicode.IsLetter(r) || unicode.IsDigit(r) || r == '_' {
			return r
		}
		return '_'
	}, name)

	// Ensure it doesn't start with a digit
	if len(sanitized) > 0 && unicode.IsDigit(rune(sanitized[0])) {
		sanitized = "_" + sanitized
	}

	// Handle reserved words by appending underscore
	if goReservedWords[sanitized] {
		return sanitized + "_"
	}

	return sanitized
}

// TemplateData contains data for code generation templates
type TemplateData struct {
	Package        string
	Queries        []QueryTemplateData
	Types          []TypeTemplateData
	Converters     []ConverterTemplateData
	FieldResolvers []TypeFieldResolverData // Field resolvers for relationship fields
}

// QueryTemplateData contains data for a query resolver
type QueryTemplateData struct {
	Name           string
	Args           []ArgTemplateData
	ReturnType     string
	Implementation string
}

// ArgTemplateData contains data for a query argument
type ArgTemplateData struct {
	Name string
	Type string
}

// TypeTemplateData contains data for a type converter
type TypeTemplateData struct {
	Name         string
	Fields       []FieldTemplateData
	UnionMembers []UnionMemberData // For union types only
}

// FieldTemplateData contains data for a field conversion
type FieldTemplateData struct {
	GraphQLName string
	Conversion  string
}

// UnionMemberData contains data for a union type member
type UnionMemberData struct {
	GraphQLType string // GraphQL type name (e.g., "Spec")
	EntityType  string // Entity type identifier (e.g., "org.semmem.spec")
}

// ConverterTemplateData contains data for a property converter function
type ConverterTemplateData struct {
	FuncName      string
	PropertyPath  string
	GoType        string
	Nullable      bool
	EnumType      string // If set, cast string to this enum type
	ComplexObject bool   // If true, this is a complex nested object type
}

// TypeFieldResolverData contains field resolvers for a GraphQL type
type TypeFieldResolverData struct {
	TypeName string                  // GraphQL type name (e.g., "Spec")
	Fields   []RelationshipFieldData // Relationship fields that need resolvers
}

// RelationshipFieldData contains data for a relationship field resolver
type RelationshipFieldData struct {
	FieldName  string // GraphQL field name (e.g., "Dependencies")
	ReturnType string // Go return type (e.g., "[]*Spec")
	EdgeType   string // Relationship edge type (e.g., "depends_on")
	Direction  string // Relationship direction ("outgoing", "incoming", "both")
	TargetType string // Target GraphQL type (e.g., "Spec")
}

// Resolver template - generates resolver.go
const resolverTemplate = `// Code generated by semstreams-gqlgen. DO NOT EDIT.

package {{.Package}}

import (
	"context"
	"fmt"
	"strconv"

	"github.com/c360/semstreams/gateway/graphql"
)

// GeneratedResolver is the root resolver (generated)
type GeneratedResolver struct {
	base *graphql.BaseResolver
}

// NewGeneratedResolver creates a new generated resolver
func NewGeneratedResolver(base *graphql.BaseResolver) *GeneratedResolver {
	return &GeneratedResolver{base: base}
}

// Query returns the query resolver
func (r *GeneratedResolver) Query() GeneratedQueryResolver {
	return &generatedQueryResolver{r}
}

// GeneratedQueryResolver resolves queries (generated)
type GeneratedQueryResolver interface {
{{- range .Queries}}
	{{.Name}}(ctx context.Context{{range .Args}}, {{.Name}} {{.Type}}{{end}}) ({{.ReturnType}}, error)
{{- end}}
}

type generatedQueryResolver struct{ *GeneratedResolver }

{{range .Queries}}
// {{.Name}} resolves the {{.Name}} query
func (r *generatedQueryResolver) {{.Name}}(ctx context.Context{{range .Args}}, {{.Name}} {{.Type}}{{end}}) ({{.ReturnType}}, error) {
	{{.Implementation}}
}
{{end}}

{{range $typeResolver := .FieldResolvers}}
// {{$typeResolver.TypeName}}Resolver resolves {{$typeResolver.TypeName}} fields
type {{$typeResolver.TypeName}}Resolver interface {
{{- range $typeResolver.Fields}}
	{{.FieldName}}(ctx context.Context, obj *{{$typeResolver.TypeName}}) ({{.ReturnType}}, error)
{{- end}}
}

// {{$typeResolver.TypeName}} returns the field resolver for {{$typeResolver.TypeName}}
func (r *GeneratedResolver) {{$typeResolver.TypeName}}() {{$typeResolver.TypeName}}Resolver {
	return &{{lower $typeResolver.TypeName}}FieldResolver{r}
}

type {{lower $typeResolver.TypeName}}FieldResolver struct{ *GeneratedResolver }

{{range $typeResolver.Fields}}
// {{.FieldName}} resolves the {{.FieldName}} field
func (r *{{lower $typeResolver.TypeName}}FieldResolver) {{.FieldName}}(ctx context.Context, obj *{{$typeResolver.TypeName}}) ({{.ReturnType}}, error) {
	if obj == nil {
		return nil, nil
	}

	// Query relationships
	rels, err := r.base.QueryRelationships(ctx, graphql.RelationshipFilters{
		EntityID:  obj.ID,
		Direction: "{{.Direction}}",
		EdgeTypes: []string{"{{.EdgeType}}"},
	})
	if err != nil {
		return nil, err
	}

	// Extract target entity IDs
	ids := make([]string, 0, len(rels))
	for _, rel := range rels {
		{{if eq .Direction "outgoing" -}}
		ids = append(ids, rel.ToEntityID)
		{{- else if eq .Direction "incoming" -}}
		ids = append(ids, rel.FromEntityID)
		{{- else -}}
		// Both directions - include both from and to
		ids = append(ids, rel.ToEntityID)
		if rel.FromEntityID != obj.ID {
			ids = append(ids, rel.FromEntityID)
		}
		{{- end}}
	}

	if len(ids) == 0 {
		return nil, nil
	}

	// Batch load entities
	entities, err := r.base.QueryEntitiesByIDs(ctx, ids)
	if err != nil {
		return nil, err
	}

	// Convert to GraphQL type
	{{if hasPrefix .ReturnType "[]" -}}
	return entities{{.TargetType}}(entities)
	{{- else -}}
	// Single result - return first entity
	if len(entities) == 0 {
		return nil, nil
	}
	return entity{{.TargetType}}(entities[0])
	{{- end}}
}
{{end}}
{{end}}
`

// Models template - generates models.go
const modelsTemplate = `// Code generated by semstreams-gqlgen. DO NOT EDIT.

package {{.Package}}

import (
	"fmt"
	"github.com/c360/semstreams/gateway/graphql"
)

{{range .Types}}
{{- if .Fields}}
// entity{{.Name}} converts Entity to GraphQL {{.Name}}
func entity{{.Name}}(e *graphql.Entity) (*{{.Name}}, error) {
	if e == nil {
		return nil, nil
	}

	return &{{.Name}}{
{{- range .Fields}}
		{{.GraphQLName}}: {{.Conversion}},
{{- end}}
	}, nil
}

// entities{{.Name}} converts multiple entities to {{.Name}} slice
func entities{{.Name}}(entities []*graphql.Entity) ([]*{{.Name}}, error) {
	result := make([]*{{.Name}}, len(entities))
	for i, e := range entities {
		converted, err := entity{{.Name}}(e)
		if err != nil {
			return nil, err
		}
		result[i] = converted
	}
	return result, nil
}
{{- else}}
// entity{{.Name}} converts Entity to GraphQL {{.Name}} (union type)
func entity{{.Name}}(e *graphql.Entity) (*{{.Name}}, error) {
	if e == nil {
		return nil, nil
	}

	// Route to concrete type based on entity type
	var result {{.Name}}
	var err error

	switch e.Type {
	{{- range .UnionMembers}}
	case "{{.EntityType}}":
		result, err = entity{{.GraphQLType}}(e)
	{{- end}}
	default:
		return nil, fmt.Errorf("unknown entity type: %s", e.Type)
	}

	if err != nil {
		return nil, err
	}
	return &result, nil
}

// entities{{.Name}} converts multiple entities to {{.Name}} slice (union type)
func entities{{.Name}}(entities []*graphql.Entity) ([]*{{.Name}}, error) {
	result := make([]*{{.Name}}, len(entities))
	for i, e := range entities {
		converted, err := entity{{.Name}}(e)
		if err != nil {
			return nil, err
		}
		result[i] = converted
	}
	return result, nil
}
{{- end}}
{{end}}
`

// Converters template - generates converters.go
const convertersTemplate = `// Code generated by semstreams-gqlgen. DO NOT EDIT.

package {{.Package}}

import (
	"github.com/c360/semstreams/gateway/graphql"
)

{{range .Converters}}
// {{.FuncName}} extracts {{.PropertyPath}} as {{.GoType}}
func {{.FuncName}}(e *graphql.Entity) {{.GoType}} {
	{{if .ComplexObject -}}
		{{if or (eq .GoType "*DecisionConsequences") (eq .GoType "DecisionConsequences") -}}
			prop := graphql.GetMapProp(e, "{{.PropertyPath}}")
			if len(prop) == 0 {
				{{if .Nullable}}return nil{{else}}return DecisionConsequences{}{{end}}
			}

			result := {{if .Nullable}}&{{end}}DecisionConsequences{
				Positive: convertToStringArray(prop["positive"]),
				Negative: convertToStringArray(prop["negative"]),
				Neutral:  convertToStringArray(prop["neutral"]),
			}
			return result
		{{else -}}
			// Unknown complex type: {{.GoType}}
			{{if .Nullable}}return nil{{else}}return {{.GoType}}{}{{end}}
		{{end -}}
	{{else if .EnumType -}}
		return {{.EnumType}}(graphql.GetStringProp(e, "{{.PropertyPath}}"))
	{{else if .Nullable -}}
		{{if eq .GoType "*string"}}return graphql.GetStringPtrProp(e, "{{.PropertyPath}}")
		{{else if eq .GoType "*int"}}return graphql.GetIntPtrProp(e, "{{.PropertyPath}}")
		{{else if eq .GoType "*float64"}}return graphql.GetFloatPtrProp(e, "{{.PropertyPath}}")
		{{else if eq .GoType "*bool"}}return graphql.GetBoolPtrProp(e, "{{.PropertyPath}}")
		{{else}}return graphql.GetStringPtrProp(e, "{{.PropertyPath}}")
		{{end}}
	{{else -}}
		{{if eq .GoType "string"}}return graphql.GetStringProp(e, "{{.PropertyPath}}")
		{{else if eq .GoType "int"}}return graphql.GetIntProp(e, "{{.PropertyPath}}")
		{{else if eq .GoType "float64"}}return graphql.GetFloatProp(e, "{{.PropertyPath}}")
		{{else if eq .GoType "bool"}}return graphql.GetBoolProp(e, "{{.PropertyPath}}")
		{{else if eq .GoType "[]string"}}return graphql.GetStringArrayProp(e, "{{.PropertyPath}}")
		{{else if eq .GoType "[]interface{}"}}return graphql.GetArrayProp(e, "{{.PropertyPath}}")
		{{else if eq .GoType "map[string]interface{}"}}return graphql.GetMapProp(e, "{{.PropertyPath}}")
		{{else}}return graphql.GetStringProp(e, "{{.PropertyPath}}")
		{{end}}
	{{end -}}
}
{{end}}

// convertToStringArray converts an interface{} to []string
// Returns empty slice if conversion fails
func convertToStringArray(val interface{}) []string {
	if val == nil {
		return []string{}
	}

	arr, ok := val.([]interface{})
	if !ok {
		return []string{}
	}

	result := make([]string, 0, len(arr))
	for _, v := range arr {
		if str, ok := v.(string); ok {
			result = append(result, str)
		}
	}
	return result
}
`

// ExecuteTemplate executes a template with the given data
func ExecuteTemplate(tmpl string, data interface{}) (string, error) {
	// Add template functions
	funcMap := template.FuncMap{
		"lower": func(s string) string {
			if s == "" {
				return s
			}
			return strings.ToLower(s[:1]) + s[1:]
		},
		"hasPrefix": strings.HasPrefix,
	}

	t, err := template.New("template").Funcs(funcMap).Parse(tmpl)
	if err != nil {
		return "", errors.WrapFatal(err, "ExecuteTemplate", "template.Parse",
			"parse template")
	}

	var buf bytes.Buffer
	if err := t.Execute(&buf, data); err != nil {
		return "", errors.WrapFatal(err, "ExecuteTemplate", "template.Execute",
			"execute template")
	}

	return buf.String(), nil
}

// GenerateResolverCode generates resolver.go content
func GenerateResolverCode(data *TemplateData) (string, error) {
	return ExecuteTemplate(resolverTemplate, data)
}

// GenerateModelsCode generates models.go content
func GenerateModelsCode(data *TemplateData) (string, error) {
	return ExecuteTemplate(modelsTemplate, data)
}

// GenerateConvertersCode generates converters.go content
func GenerateConvertersCode(data *TemplateData) (string, error) {
	return ExecuteTemplate(convertersTemplate, data)
}

// buildConverterFuncName creates a function name for a property converter
// Example: "properties.name" -> "getName"
// Example: "properties.category", true -> "getCategoryPtr"
// Example: "updated_at" (no prefix) -> "getUpdated_atDirect"
func buildConverterFuncName(propertyPath string, nullable bool) string {
	// Split by dots
	parts := strings.Split(propertyPath, ".")

	// Get the base name
	var baseName string
	if len(parts) == 1 {
		// Single part (e.g., "id", "updated_at") - add "Direct" suffix to avoid collisions
		baseName = capitalize(parts[0]) + "Direct"
	} else if len(parts) == 2 && parts[0] == "properties" {
		// Standard "properties.field" pattern
		baseName = capitalize(parts[1])
	} else {
		// Other nested paths - use full path with underscores
		baseName = ""
		for i, part := range parts {
			if i > 0 {
				baseName += "_"
			}
			baseName += capitalize(part)
		}
	}

	// Add Ptr suffix for nullable fields
	if nullable {
		return "get" + baseName + "Ptr"
	}
	return "get" + baseName
}

// capitalize capitalizes the first letter of a string
// Special handling for common GraphQL field names like "id", "url", etc.
// Also handles compound words like "githubUrl" -> "GithubURL"
// Sanitizes input to ensure valid Go identifiers
func capitalize(s string) string {
	if s == "" {
		return s
	}

	// Sanitize first to ensure valid identifier
	s = sanitizeIdentifier(s)
	if s == "" {
		return s
	}

	// Handle special cases (GraphQL naming conventions) - whole word
	switch strings.ToLower(s) {
	case "id", "id_":
		return "ID"
	case "url", "url_":
		return "URL"
	case "uri", "uri_":
		return "URI"
	case "api", "api_":
		return "API"
	}

	// Handle compound words like "githubUrl" -> "GithubURL"
	// Check for common suffixes that should be all caps
	suffixes := []string{"Url", "Uri", "Api", "Id"}
	for _, suffix := range suffixes {
		if strings.HasSuffix(s, suffix) {
			prefix := s[:len(s)-len(suffix)]
			upperSuffix := strings.ToUpper(suffix)
			if prefix == "" {
				return upperSuffix
			}
			// Capitalize first letter of prefix
			if len(prefix) == 1 {
				return strings.ToUpper(prefix) + upperSuffix
			}
			return strings.ToUpper(prefix[:1]) + prefix[1:] + upperSuffix
		}
	}

	if len(s) == 1 {
		return strings.ToUpper(s)
	}
	return strings.ToUpper(s[:1]) + s[1:]
}

// buildConversion generates the conversion code for a field
func buildConversion(fieldConfig FieldConfig, converterName string) string {
	if fieldConfig.Property != "" {
		// Use property converter
		return converterName + "(e)"
	}

	// TODO: Handle relationship resolvers
	return `"" /* TODO: relationship resolver */`
}

// buildQueryImplementation generates the implementation code for a query resolver
func buildQueryImplementation(queryName string, queryConfig QueryConfig, schema *SchemaInfo) (string, error) {
	query, exists := schema.Queries[queryName]
	if !exists {
		return "", fmt.Errorf("query %s not found in schema", queryName)
	}

	// Get return type
	returnTypeName := GetBaseTypeName(query.Type)
	isList := IsListType(query.Type)

	switch queryConfig.Resolver {
	case "QueryEntityByID":
		// Single entity query - use first argument as ID parameter
		if len(query.Arguments) == 0 {
			return "", fmt.Errorf("QueryEntityByID requires at least one argument")
		}
		idParam := query.Arguments[0].Name
		idParamType := GetBaseTypeName(query.Arguments[0].Type)

		// Add type conversion if parameter is Int
		idValue := idParam
		if idParamType == "Int" {
			idValue = fmt.Sprintf("strconv.Itoa(%s)", idParam)
		}

		return fmt.Sprintf(`entity, err := r.base.QueryEntityByID(ctx, %s)
	if err != nil {
		return nil, err
	}
	return entity%s(entity)`, idValue, returnTypeName), nil

	case "QueryEntitiesByIDs":
		// Multiple entities query - use first argument as IDs parameter
		if len(query.Arguments) == 0 {
			return "", fmt.Errorf("QueryEntitiesByIDs requires at least one argument")
		}
		idsParam := query.Arguments[0].Name
		return fmt.Sprintf(`entities, err := r.base.QueryEntitiesByIDs(ctx, %s)
	if err != nil {
		return nil, err
	}
	return entities%s(entities)`, idsParam, returnTypeName), nil

	case "QueryRelationships":
		// Relationship query
		if !isList {
			return "", fmt.Errorf("QueryRelationships must return a list type")
		}
		return `// TODO: implement relationship query
	return nil, nil`, nil

	case "QueryEntitiesByType":
		// List entities by type query
		if !isList {
			return "", fmt.Errorf("QueryEntitiesByType must return a list type")
		}
		// Need to get entity_type from config
		if queryConfig.EntityType == "" {
			return "", fmt.Errorf("QueryEntitiesByType requires entity_type in config")
		}
		return fmt.Sprintf(`entities, err := r.base.QueryEntitiesByType(ctx, "%s", limit)
	if err != nil {
		return nil, err
	}
	return entities%s(entities)`, queryConfig.EntityType, returnTypeName), nil

	case "SemanticSearch":
		// Semantic search query
		if !isList {
			return "", fmt.Errorf("SemanticSearch must return a list type")
		}
		return fmt.Sprintf(`results, err := r.base.SemanticSearch(ctx, query, limit)
	if err != nil {
		return nil, err
	}

	// Convert search results to entities
	entities := make([]*graphql.Entity, len(results))
	for i, result := range results {
		entities[i] = result.Entity
	}

	return entities%s(entities)`, returnTypeName), nil

	case "QueryEntityByAlias":
		// Entity lookup by alias or ID
		if len(query.Arguments) == 0 {
			return "", fmt.Errorf("QueryEntityByAlias requires at least one argument")
		}
		aliasParam := query.Arguments[0].Name
		return fmt.Sprintf(`entity, err := r.base.QueryEntityByAlias(ctx, %s)
	if err != nil {
		return nil, err
	}
	return entity%s(entity)`, aliasParam, returnTypeName), nil

	case "LocalSearch":
		// Local search within entity's community
		// Expected args: entityID, query, level
		if len(query.Arguments) < 3 {
			return "", fmt.Errorf("LocalSearch requires 3 arguments: entityID, query, level")
		}
		return fmt.Sprintf(`result, err := r.base.LocalSearch(ctx, entityID, query, level)
	if err != nil {
		return nil, err
	}
	if result == nil || len(result.Entities) == 0 {
		return nil, nil
	}
	return entities%s(result.Entities)`, returnTypeName), nil

	case "GlobalSearch":
		// Global search across community summaries
		// Expected args: query, level, maxCommunities
		if len(query.Arguments) < 3 {
			return "", fmt.Errorf("GlobalSearch requires 3 arguments: query, level, maxCommunities")
		}
		return fmt.Sprintf(`result, err := r.base.GlobalSearch(ctx, query, level, maxCommunities)
	if err != nil {
		return nil, err
	}
	if result == nil || len(result.Entities) == 0 {
		return nil, nil
	}
	return entities%s(result.Entities)`, returnTypeName), nil

	case "GetCommunity":
		// Get community by ID - returns graphql.Community directly
		if len(query.Arguments) == 0 {
			return "", fmt.Errorf("GetCommunity requires at least one argument (communityID)")
		}
		communityIDParam := query.Arguments[0].Name
		return fmt.Sprintf(`community, err := r.base.GetCommunity(ctx, %s)
	if err != nil {
		return nil, err
	}
	// Community struct is already JSON-serializable and matches GraphQL schema
	return community, nil`, communityIDParam), nil

	case "GetEntityCommunity":
		// Get entity's community at a specific level - returns graphql.Community directly
		if len(query.Arguments) < 2 {
			return "", fmt.Errorf("GetEntityCommunity requires 2 arguments: entityID, level")
		}
		return `community, err := r.base.GetEntityCommunity(ctx, entityID, level)
	if err != nil {
		return nil, err
	}
	// Community struct is already JSON-serializable and matches GraphQL schema
	return community, nil`, nil

	case "Custom":
		// Custom resolver - generate placeholder
		return fmt.Sprintf(`// TODO: implement custom resolver for %s
	return nil, fmt.Errorf("not implemented")`, queryName), nil

	default:
		return "", fmt.Errorf("unknown resolver: %s", queryConfig.Resolver)
	}
}

// mapGraphQLTypeToGo maps GraphQL types to Go types
func mapGraphQLTypeToGo(gqlType *ast.Type) string {
	if gqlType == nil {
		return "interface{}"
	}

	baseName := GetBaseTypeName(gqlType)
	isList := IsListType(gqlType)

	// Map base type
	var goType string
	switch baseName {
	case "ID", "String":
		goType = "string"
	case "Int":
		goType = "int"
	case "Float":
		goType = "float64"
	case "Boolean":
		goType = "bool"
	default:
		// Custom type - pointer to type
		goType = "*" + baseName
	}

	// Wrap in slice if list
	if isList {
		goType = "[]" + goType
	}

	return goType
}
